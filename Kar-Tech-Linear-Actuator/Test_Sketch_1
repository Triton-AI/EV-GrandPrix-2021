// demo: CAN-BUS Shield, send data
// loovee@seeed.cc

//this sketch focuses on sending the LA to a specific position


#include <SPI.h>

#define CAN_2515
// #define CAN_2518FD

// Set SPI CS Pin according to your hardware

#if defined(SEEED_WIO_TERMINAL) && defined(CAN_2518FD)
// For Wio Terminal w/ MCP2518FD RPi Hatï¼š
// Channel 0 SPI_CS Pin: BCM 8
// Channel 1 SPI_CS Pin: BCM 7
// Interupt Pin: BCM25
const int SPI_CS_PIN  = BCM8;
const int CAN_INT_PIN = BCM25;
#else

// For Arduino MCP2515 Hat:
// the cs pin of the version after v1.1 is default to D9
// v0.9b and v1.0 is default D10
const int SPI_CS_PIN = 9;
const int CAN_INT_PIN = 2;
#endif


#ifdef CAN_2518FD
#include "mcp2518fd_can.h"
mcp2518fd CAN(SPI_CS_PIN); // Set CS pin
#endif

#ifdef CAN_2515
#include "mcp2515_can.h"
mcp2515_can CAN(SPI_CS_PIN); // Set CS pin
#endif

// sequence to move actuator to 1" with no reply from actuator
unsigned char stmp1[8] = {0x0F, 0x0A, 0xFC, 0x85, 0x00, 0x00, 0x00, 0x00}; //20ms
unsigned char stmp2[8] = {0x0F, 0x0A, 0xFC, 0xC5, 0x00, 0x00, 0x00, 0x00}; //repeat every 900ms if clutch is to stay on
unsigned char stmp3[8] = {0x0F, 0x0A, 0xFC, 0x85, 0x00, 0x00, 0x00, 0x00}; //900ms
unsigned char stmp4[8] = {0x0F, 0x0A, 0xFC, 0x05, 0x00, 0x00, 0x00, 0x00}; //20ms

//automatic reply from actuator when end position is reached
//at end position, turn off motor and clutch (1")
unsigned char stmp5[8] = {0x0F, 0x0A, 0xFC, 0x85, 0x00, 0x00, 0x00, 0x00}; //20ms
unsigned char stmp6[8] = {0x0F, 0x4A, 0xFC, 0xC5, 0x00, 0x00, 0x00, 0x00}; //repeat every 100ms until you see the position is at 1", or within a deadband of 1"
unsigned char stmp7[8] = {0x0F, 0x0A, 0xFC, 0x85, 0x00, 0x00, 0x00, 0x00}; //20ms
unsigned char stmp8[8] = {0x0F, 0x0A, 0xFC, 0x05, 0x00, 0x00, 0x00, 0x00}; 

//send to 2 inches
unsigned char pos_2[8] = {0x0F, 0x4A, 0xC4, 0xC9, 0x00, 0x00, 0x00, 0x00}; 

//This sets the 4th user defined command ID to 0x00FF0302, and disables the Default Command ID.
//Until power is cycled, this actuator will ignore commands set to the default actuator Command ID
//Byte 1 which is '0xF7' implies this is a Command Id assignment message
unsigned char command_id[8] = {0xF7, 0x04, 0x02, 0x03, 0xFF, 0x00, 0x00, 0x00};

//this is just a function for testing
void test1_func(){

  //create messages
  // sequence to move actuator to 1" with no reply from actuator
  unsigned char stmp1[8] = {0x0F, 0x0A, 0xFC, 0x85, 0x00, 0x00, 0x00, 0x00}; //20ms
  unsigned char stmp2[8] = {0x0F, 0x0A, 0xFC, 0xC5, 0x00, 0x00, 0x00, 0x00}; //repeat every 900ms if clutch is to stay on
  unsigned char stmp3[8] = {0x0F, 0x0A, 0xFC, 0x85, 0x00, 0x00, 0x00, 0x00}; //900ms
  unsigned char stmp4[8] = {0x0F, 0x0A, 0xFC, 0x05, 0x00, 0x00, 0x00, 0x00}; //20ms

  //this message sets the position report to be sent every 100ms

  //Send Message Sequence
  CAN.sendMsgBuf(0x00FF0302, CAN_EXTID, 8, stmp1);
  delay(100);                       // send data per 100ms

  CAN.sendMsgBuf(0x00FF0302, CAN_EXTID, 8, stmp2);
  delay(100);                       // send data per 100ms

  CAN.sendMsgBuf(0x00FF0302, CAN_EXTID, 8, stmp3);
  delay(100);                       // send data per 100ms

  CAN.sendMsgBuf(0x00FF0302, CAN_EXTID, 8, stmp4);
  delay(100);                       // send data per 100ms
  
  //Report message
  SERIAL_PORT_MONITOR.println("CAN BUS sendMsgBuf ok!");

  }

void setup() {
    SERIAL_PORT_MONITOR.begin(115200);
    while(!Serial){};

    while (CAN_OK != CAN.begin(CAN_250KBPS)) {             // init can bus : baudrate = 500k
        SERIAL_PORT_MONITOR.println("CAN init fail, retry...");
        delay(100);
    }
    SERIAL_PORT_MONITOR.println("CAN init ok!");
    
    //Command ID assignment
    //Note, the LA should be assigned already with the 0x00FF0302 command ID
    //You only need to run the following two lines if you attach a new actuator to the bus
    
//    CAN.sendMsgBuf(0x00, CAN_EXTID, 8, command_id);
//    delay(100);                       // send data per 100ms
}



void loop() {
// send data:  id = 0x00, standrad frame, data len = 8, stmp: data buf

//call test function
test1_func();


    

    
}

// END FILE
